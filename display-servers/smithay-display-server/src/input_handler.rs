use smithay::{
    backend::input::{AbsolutePositionEvent, Event, InputBackend, PointerMotionEvent},
    input::pointer::{MotionEvent, RelativeMotionEvent},
    utils::{Logical, Point, SERIAL_COUNTER},
};

use crate::{managed_window::ManagedWindow, state::SmithayState};

impl SmithayState {
    pub fn on_pointer_move<B: InputBackend>(&mut self, event: B::PointerMotionEvent) {
        let serial = SERIAL_COUNTER.next_serial();
        self.pointer_location += event.delta();

        // clamp to screen limits
        // this event is never generated by winit
        self.pointer_location = self.clamp_coords(self.pointer_location);
        self.focus_window_under();

        let under = self.surface_under();

        if let Some(ptr) = self.seat.get_pointer() {
            ptr.motion(
                self,
                under.clone(),
                &MotionEvent {
                    location: self.pointer_location,
                    serial,
                    time: event.time_msec(),
                },
            );

            ptr.relative_motion(
                self,
                under,
                &RelativeMotionEvent {
                    delta: event.delta(),
                    delta_unaccel: event.delta_unaccel(),
                    utime: event.time(),
                },
            )
        }
    }

    pub fn on_pointer_move_absolute<B: InputBackend>(
        &mut self,
        event: B::PointerMotionAbsoluteEvent,
    ) {
        let serial = SERIAL_COUNTER.next_serial();

        let max_x = self.outputs.iter().fold(0, |acc, (_, g)| acc + g.size.w);

        let highest_output = self.outputs.iter().max_by_key(|(_, o)| o.size.h).unwrap();

        let max_y = highest_output.1.size.h;

        self.pointer_location.x = event.x_transformed(max_x);
        self.pointer_location.y = event.y_transformed(max_y);

        self.pointer_location = self.clamp_coords(self.pointer_location);

        let under = self.surface_under();
        if let Some(ptr) = self.seat.get_pointer() {
            ptr.motion(
                self,
                under,
                &MotionEvent {
                    location: self.pointer_location,
                    serial,
                    time: event.time_msec(),
                },
            )
        }
    }

    fn clamp_coords(&self, pos: Point<f64, Logical>) -> Point<f64, Logical> {
        if self.outputs.is_empty() {
            return pos;
        }

        let (pos_x, pos_y) = pos.into();
        let max_x = self.outputs.iter().fold(0, |acc, (_, g)| acc + g.size.w);
        let clamped_x = pos_x.max(0.0).min(max_x as f64);
        let max_y = self
            .outputs
            .iter()
            .find(|(_, g)| g.contains((clamped_x as i32, 0)))
            .map(|(_, g)| g.size.h);

        if let Some(max_y) = max_y {
            let clamped_y = pos_y.max(0.0).min(max_y as f64);
            (clamped_x, clamped_y).into()
        } else {
            (clamped_x, pos_y).into()
        }
    }

    pub fn surface_under(&self) -> Option<(ManagedWindow, Point<i32, Logical>)> {
        let pos = self.pointer_location;
        // let (output, output_geo) = self
        //     .outputs
        //     .iter()
        //     .find(|(_, g)| g.contains(pos.to_i32_round()))?;
        // let layers = layer_map_for_output(output);

        let mut under = None;
        // if let Some(window) = output
        //     .user_data()
        //     .get::<FullscreenSurface>()
        //     .and_then(|f| f.get())
        // {
        //     under = Some((window.into(), output_geo.loc));
        // } else if let Some(layer) = layers
        //     .layer_under(WlrLayer::Overlay, pos)
        //     .or_else(|| layers.layer_under(WlrLayer::Top, pos))
        // {
        //     let layer_loc = layers.layer_geometry(layer).unwrap().loc;
        //     under = Some((layer.clone().into(), output_geo.loc + layer_loc))
        // } else if let Some((window, location)) = self.space.element_under(pos) {
        //     under = Some((window.clone().into(), location));
        // } else if let Some(layer) = layers
        //     .layer_under(WlrLayer::Bottom, pos)
        //     .or_else(|| layers.layer_under(WlrLayer::Background, pos))
        // {
        //     let layer_loc = layers.layer_geometry(layer).unwrap().loc;
        //     under = Some((layer.clone().into(), output_geo.loc + layer_loc));
        // };
        if let Some((window, location)) = self.window_registry.window_under(pos.to_i32_ceil()) {
            under = Some((window.clone(), location))
        }

        under
    }
}
